import numpy as np
from OASIS import visualize
from gtsam import Point3, Cal3_S2, PinholeCameraCal3_S2, Pose3
import math
import gtsam
from typing import List
import matplotlib.pyplot as plt
from gtsam.utils import plot
import time
from scipy.spatial.transform import Rotation as R

'''
Methods related to generating simulation data
'''

'''
A method which reads the file generated by SO3_grid c++
code to sample via hof fibration.
'''
def sample_rotations_hopf(filename):
    global figno
    with open(filename, 'r') as f:
        quat_samples = f.readlines()
    plt.ion()
    fig = plt.figure(figno)
    figno = figno + 1
    axes = fig.add_subplot(111, projection='3d')
    rot_mats = np.zeros((0, 3,3))
    for i, quat in enumerate(quat_samples):
        quat_np = np.fromstring(quat, dtype=float, sep=' ')
        r = R.from_quat(quat_np)
        rmat = r.as_matrix()
        rot_mats = np.append(rot_mats, rmat[None], axis=0)
        c1 = gtsam.Pose3(gtsam.Rot3(rmat), gtsam.Point3(0, 0, 0))
        for j, quat2 in enumerate(quat_samples):

            quat_np2 = np.fromstring(quat2, dtype=float, sep=' ')
            r2 = R.from_quat(quat_np2)
            rmat2 = r2.as_matrix()

            c2 = gtsam.Pose3(gtsam.Rot3(rmat2), gtsam.Point3(0.1, 0, 0))
            plot.plot_pose3_on_axes(axes, c1, 0.1)
            plot.plot_pose3_on_axes(axes, c2, 0.1)
            axes.set_xlim3d([-0.2, 0.2])
            axes.set_ylim3d([-0.2, 0.2])
            axes.set_zlim3d([-0.2, 0.2])
            fig.canvas.draw()
            fig.canvas.flush_events()

            axes.cla()
            #time.sleep(0.2)
    plt.show()
    return rot_mats
'''
A method which samples rotation from a sphere

'''
def sample_rotations_sphere(azi_range, azi_num_samples, elev_range, elev_num_samples, to_plot= False):
    global figno
    if to_plot:
        plt.ion()
        fig = plt.figure(figno)
        figno = figno + 1
        axes = fig.add_subplot(111, projection='3d')
    rot_mats = np.zeros((0, 3, 3))
    #del_azi = 60.0 * math.pi / 180.0
    #del_elev = 30.0 * math.pi / 180.0
    for del_elev in  np.linspace(elev_range[0], elev_range[1], elev_num_samples): #np.linspace(0, math.pi/4, 3):
        for del_azi in np.linspace(azi_range[0], azi_range[1], azi_num_samples):#np.linspace(0, (2*math.pi - math.pi/3), 6):
            R_y = np.array([[math.cos(del_azi), 0, math.sin(del_azi)],
                            [0, 1, 0],
                            [-1 * math.sin(del_azi), 0, math.cos(del_azi)]])

            R_x = np.array([[1.0, 0.0, 0.0],
                            [0, math.cos(del_elev), -1 * math.sin(del_elev)],
                            [0, math.sin(del_elev), math.cos(del_elev)]])
            rotmat =  R_y @ R_x
            rot_mats = np.append(rot_mats, rotmat[None], axis=0)
            c = gtsam.Pose3(gtsam.Rot3(rotmat), gtsam.Point3(0, 0, 0))

            if to_plot:
                plot.plot_pose3_on_axes(axes, c, 0.7)
                # # draw sphere
                # u, v = np.mgrid[0:2 * np.pi:20j, 0:np.pi:10j]
                # x = np.cos(u) * np.sin(v)
                # y = np.sin(u) * np.sin(v)
                # z = np.cos(v)
                # axes.plot_wireframe(x, y, z, color="r")
                axes.quiver(0, 0, 0, rotmat[0,2], rotmat[1,2], rotmat[2,2])
                fig.canvas.draw()
                fig.canvas.flush_events()
                axes.cla()
                time.sleep(0.1)
    return rot_mats

def generate_candidate_poses(azi_range, azi_num_samples, elev_range, elev_num_samples, min_baseline = 0.15):
    # Sample the space of position and rotation
    pose_rots = sample_rotations_sphere(azi_range, azi_num_samples, elev_range, elev_num_samples, False)

    pose_trans = [[-min_baseline, 0, min_baseline], [0, 0, min_baseline], [min_baseline, 0, min_baseline],
                 [-min_baseline, 0, 0], [min_baseline, 0, 0],
                 [-min_baseline, 0, -min_baseline], [0, 0, -min_baseline], [min_baseline, 0, -min_baseline]]
    #pose_trans = [[-2.0 * min_baseline, 0, 0], [-min_baseline, 0, 0], [0, 0, 0], [min_baseline, 0, 0],  [2.0 * min_baseline, 0, 0]]
    return pose_rots, pose_trans

def generate_extr_cands_phy(pose_trans, pose_rots):
    extr_cand=[] # right now this is implemented only for single elevation angle
    for j, trans in enumerate(pose_trans):
        rot_inds = list(range(len(pose_rots)))
        if j ==0: # no right bottom
            del rot_inds[4:6]
        elif j == 1: #no lower half
            del rot_inds[4:9]
        elif j == 2: # no left bottom
            del rot_inds[7:9]
        elif j == 3: # no right half
            del rot_inds[1:6]
        elif j == 4: # no left half
            del rot_inds[7:12]
        elif j == 5: # no upper right
            del rot_inds[1:3]
        elif j == 6 : # no upper half
            del rot_inds[0:3]
            del rot_inds[7:9]
        elif j == 7: # no upper left
            del rot_inds[10:12]
        for k in rot_inds:
            rot = pose_rots[k]
            cam = gtsam.Pose3(gtsam.Rot3(rot), gtsam.Point3(trans[0], trans[1], trans[2]))
            extr_cand.append(cam)
    return extr_cand

def generate_candidate_poses_equal(select_k_list, min_baseline=0.15):
    pose_rots, pose_trans = generate_candidate_poses((0, 330 / 180 * math.pi), 12, (0, math.pi / 2),1)
    extr_cand =[]

    trans = {2:[3, 4], 3:[3,1,4], 4:[3,1,4,6], 5:[1,4,7,5,3], 6:[1,2,7,6,5,0]}
    thetas= {2:[9, 3], 3:[9, 0, 3], 4:[9, 0,3,6], 5:[0,2,5,8,10], 6:[0,2,4,6,8,10]}
    ''' older code'''
    # for two cameras to 7. uncomment below for azimuth of ((0, 3 / 2 * math.pi), 7)
    # trans = {2: [4, 3], 3: [1, 4, 3], 4: [1, 4, 6, 3], 5: [1, 4, 7, 5, 3], 6: [1, 4, 7, 6, 5, 3],
    #          7: [1, 2, 4, 7, 5, 3, 0]}
    # thetas = {2: [90, 270], 3: [0, 90, 270], 4: [0, 90, 180, 270], 5: [0, 72, 144, 216, 288],
    #           6: [0, 60, 120, 180, 240, 300], 7: [0, 45, 90, 135, 225, 270, 315]}
    # for k in select_k_list:
    #     cur_thetas = thetas[k]
    #     cur_trans = trans[k]
    #     for (r, t) in zip(cur_thetas, cur_trans):
    #         R_y = np.array([[math.cos(t), 0, math.sin(t)],
    #                 [0, 1, 0],
    #                 [-1 * math.sin(t), 0, math.cos(t)]])
    #         cam = gtsam.Pose3(gtsam.Rot3(R_y), gtsam.Point3(pose_trans[t][0], pose_trans[t][1], pose_trans[t][2]))
    #         extr_cand.append(cam)
    '''---------------------'''
    for k in select_k_list:
        cur_theta_inds = thetas[k]
        cur_trans_inds = trans[k]
        for (r, t) in zip(cur_theta_inds, cur_trans_inds):
            rot = pose_rots[r]
            cam = gtsam.Pose3(gtsam.Rot3(rot), gtsam.Point3(pose_trans[t][0], pose_trans[t][1], pose_trans[t][2]))
            extr_cand.append(cam)
    return extr_cand

def generate_candidate_poses_stnd(select_k_list, min_baseline=0.15):
    pose_rots, pose_trans = generate_candidate_poses((0, 330 / 180 * math.pi), 12, (0, math.pi / 2), 1)
    extr_cand = []

    trans = {2: [0,2], 3: [3, 1, 4], 4: [3, 0, 2, 4], 5: [3,0,2,4,6], 6: [5,3,0,2,4,7]}
    thetas = {2: [0, 0], 3: [9, 0, 3], 4: [9, 0, 0, 3], 5: [9,0,0,3,6], 6: [9,9,0,0,3,3]}

    for k in select_k_list:
        cur_theta_inds = thetas[k]
        cur_trans_inds = trans[k]
        for (r, t) in zip(cur_theta_inds, cur_trans_inds):
            rot = pose_rots[r]
            cam = gtsam.Pose3(gtsam.Rot3(rot), gtsam.Point3(pose_trans[t][0], pose_trans[t][1], pose_trans[t][2]))
            extr_cand.append(cam)

    # pose_trans = [[-min_baseline, 0, min_baseline], [0, 0, min_baseline], [min_baseline, 0, min_baseline],
    #               [-min_baseline, 0, 0], [min_baseline, 0, 0],
    #               [-min_baseline, 0, -min_baseline], [0, 0, -min_baseline], [min_baseline, 0, -min_baseline]]
    # # for two cameras
    # trans = {2:[0, 2], 3:[1,4,3], 4:[0,2,4, 3], 5:[0, 2, 4, 3, 6], 6: [0,2,4,3,7,5], 7:[0,2,4,7,6,3,5]}
    # thetas= {2:[0, 0], 3:[0, 90, 270], 4:[0, 0,90, 270], 5:[0, 0, 90, 270, 180], 6:[0, 0, 90, 270, 90, 270], 7:[0, 0,90, 90, 180, 270, 270]}
    # for k in select_k_list:
    #     cur_thetas = thetas[k]
    #     cur_trans = trans[k]
    #     for (r, t) in zip(cur_thetas, cur_trans):
    #         R_y = np.array([[math.cos(t), 0, math.sin(t)],
    #                 [0, 1, 0],
    #                 [-1 * math.sin(t), 0, math.cos(t)]])
    #         cam = gtsam.Pose3(gtsam.Rot3(R_y), gtsam.Point3(pose_trans[t][0], pose_trans[t][1], pose_trans[t][2]))
    #         extr_cand.append(cam)
    return extr_cand

def createPoints() -> List[Point3]:
    # Create the set of ground-truth landmarks
    points = [
        Point3(10.0, 10.0, 10.0),
        Point3(-10.0, 10.0, 10.0),
        Point3(-10.0, -10.0, 10.0),
        Point3(10.0, -10.0, 10.0),
        Point3(10.0, 10.0, -10.0),
        Point3(-10.0, 10.0, -10.0),
        Point3(-10.0, -10.0, -10.0),
        Point3(10.0, -10.0, -10.0),
    ]
    return points

def createPoints2(num_points, cubesize):
    x = -(cubesize/2) + np.random.rand(num_points) * cubesize
    y = -(cubesize/2) + np.random.rand(num_points) * cubesize
    z = -(cubesize/2) + np.random.rand(num_points) * cubesize
    points= [ Point3(x[i],y[i],z[i]) for i in range(num_points)]
    return points

def makePoses(K: Cal3_S2) -> List[Pose3]:
    """Generate a set of ground-truth camera poses arranged in a circle about the origin."""
    radius = 40.0
    height = 10.0
    angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)
    up = gtsam.Point3(0, 0, 1)
    target = gtsam.Point3(0, 0, 0)
    poses = []
    for theta in angles:
        position = gtsam.Point3(radius * np.cos(theta), radius * np.sin(theta), height)
        camera = gtsam.PinholeCameraCal3_S2.Lookat(position, target, up, K)
        poses.append(camera.pose())
    return poses

def create_corridor_world(num_points, K):
    plt.ion()
    fig1, ax1 = visualize.initialize_3d_plot(number=1, limits=np.array([[-30, 30], [-30, 30], [-30, 30]]),
                                                    view=[-30, -90])

    # helper_functions.plot_3d_points(ax1, pp, None, 'bo', markersize=2)

    # generate random points on xy plane
    #num_points = 40
    x = -10 + np.random.rand(num_points) * 20
    y = -5 + np.random.rand(num_points) * 10
    z = np.zeros((1, num_points))

    # rotate the points
    R_y = np.array([[math.cos(math.pi / 2), 0, math.sin(math.pi / 2)],
                    [0, 1, 0],
                    [-1 * math.sin(math.pi / 2), 0, math.cos(math.pi / 2)]])

    R_z = np.array([[math.cos(math.pi / 2), -1 * math.sin(math.pi / 2), 0.0],
                    [math.sin(math.pi / 2), math.cos(math.pi / 2), 0.0],
                    [0, 0, 1.0]])

    R_z_neg = np.array([[math.cos(math.pi / 2), math.sin(math.pi / 2), 0.0],
                        [-1 * math.sin(math.pi / 2), math.cos(math.pi / 2), 0.0],
                        [0, 0, 1.0]])

    R_x = np.array([[1.0, 0.0, 0.0],
                    [0, math.cos(math.pi / 2), -1 * math.sin(math.pi / 2)],
                    [0, math.sin(math.pi / 2), math.cos(math.pi / 2)]])

    points = np.vstack((x, y, z))
    #left wall
    rotated_points_1 = (R_x @ R_y @ points).T + np.array([-4.5, 0, 5.0])

    # helper_functions.plot_3d_points(ax1, points.T, None, 'bo', markersize=2)
    visualize.plot_3d_points(ax1, rotated_points_1, None, 'ro', markersize=2)

    # #front wall
    num_points = 100
    x = -20 + np.random.rand(num_points) * 40
    y = -5 + np.random.rand(num_points) * 10
    z = np.zeros((1, num_points))
    points = np.vstack((x, y, z))
    rotated_points_2 = (R_x @ points).T + np.array([0.0, 10.5, 5.0])
    rotated_points_2 = rotated_points_2[rotated_points_2[:, 0] < 3.5]
    rotated_points_2 = rotated_points_2[rotated_points_2[:, 0] > -3.5]
    visualize.plot_3d_points(ax1, rotated_points_2, None, 'ro', markersize=2)

    # #front wall
    num_points = 40
    x = -10 + np.random.rand(num_points) * 20
    y = -5 + np.random.rand(num_points) * 10
    z = np.zeros((1, num_points))
    points = np.vstack((x, y, z))
    #right wall
    rotated_points_3 = (R_z_neg @ R_x @ points).T + np.array([4.5, 0.0, 5.0])
    visualize.plot_3d_points(ax1, rotated_points_3, None, 'ro', markersize=2)

    # #back wall
    #rotated_points_4 = (R_x @ points).T + np.array([0.0, -20.5, 5.0])
    #helper_functions.plot_3d_points(ax1, rotated_points_4, None, 'ro', markersize=2)

    points = np.vstack((rotated_points_1, rotated_points_3, rotated_points_2 ))
    points_gtsam = [Point3(points[i, 0], points[i, 1], points[i, 2]) for i in range(points.shape[0])]
    print(points_gtsam)

    # plot GTSAM poses straight line path
    poses = []
    num_poses = 15
    dist = 15
    vel_cmds = []
    r = np.array([[1, 0, 0],
                  [0, 0, 1],
                  [0, -1, 0]])
    up = gtsam.Point3(0, 0, 1)
    position = gtsam.Point3(0, -20.0, 5.0)
    target =  gtsam.Point3(0.0, 20.0, 5.0)
    camera = gtsam.PinholeCameraCal3_S2.Lookat(position, target, up, K)

    for i in range(20):
        w = np.array([[0, 0, 0]]).T
        v = np.array([[0, 0, 0.5]]).T
        vel_cmds.append(np.vstack((w, v)))
    poses = create_random_robot_traj(camera.pose().rotation().matrix(), np.array([0,-10.0,5.0]),20, vel_cmds)

    # for i in range(dist):
    #     # r = np.array([[1,0,0],
    #     #           [0,0,1],
    #     #           [0,-1, 0]])
    #
    #     poses.append(gtsam.Pose3(gtsam.Rot3(r), gtsam.Point3(0,-20+2*i,5.0)))
    #     plot.plot_pose3_on_axes(ax1, poses[-1], axis_length=0.1, P=None, scale=1)

    #plt.show()
    # sanity check
    dict={}
    for i, pose in enumerate(poses):
        plot.plot_pose3_on_axes(ax1, pose, axis_length=1, P=None, scale=1)
        camera = PinholeCameraCal3_S2(pose, K)
        num_projected = 0
        for j, point in enumerate(points_gtsam):
            try:
                measurement = camera.project(point) + 1.0 * np.random.randn(2)
                if (measurement[0] > 1 and measurement[0] < 2 * K.px() and measurement[1] > 1 and measurement[
                    1] < 2 * K.py()):
                    num_projected = num_projected + 1
                    plot.plot_point3_on_axes(ax1, point, 'b*')
                    if dict.get(j) is None:
                        dict[j] = 1
                    else:
                        dict[j] = dict[j] + 1
                # else:
                # print("Measurement is out of bounds: ")
                # print(measurement)
            except Exception:
                pass
                # print("Exception at Point")
                # print(point)
        fig1.canvas.draw()
        fig1.canvas.flush_events()
        ax1.cla()
        time.sleep(0.5)
        ax1.set_xlabel("X_axis")
        ax1.set_ylabel("Y_axis")
        ax1.set_zlabel("Z_axis")

        visualize.plot_3d_points(ax1, rotated_points_1, None, 'ro', markersize=2)
        visualize.plot_3d_points(ax1, rotated_points_2, None, 'ro', markersize=2)
        visualize.plot_3d_points(ax1, rotated_points_3, None, 'ro', markersize=2)
        #helper_functions.plot_3d_points(ax1, rotated_points_4, None, 'ro', markersize=2)
        print(pose)
        print("number of projected measurements for pose : " + str(i) + " is : " + str(num_projected))
        plt.show()
    rm_indices=[]
    for k,v in dict.items():
        if v < 3:
            print("lm index: "+str(k)+", lm value : "+ str(points_gtsam[k]))
            rm_indices.append(k)
    final_points_gtsam=[]
    for i,pt in enumerate(points_gtsam):
        if i not in rm_indices:
            final_points_gtsam.append(pt)
    print(len(final_points_gtsam))

    return final_points_gtsam, poses

def create_random_robot_traj(start_rot=np.eye(3), start_trans=np.array([0,0,0]), num_poses=30, vel_cmds=None):

    curPose = gtsam.Pose3(gtsam.Rot3(start_rot), gtsam.Point3(start_trans))
    poses = []
    if vel_cmds is not None:
        assert( len(vel_cmds) == num_poses)
    for i in range(num_poses):
        poses.append(curPose)

        if vel_cmds is None:
            #checkthe bounds
            delTheta_c = -1.0*(math.pi / 180.0 * 30)
            w_l = np.array([[0, delTheta_c , 0]]).T
            v_l = np.array([[4.0*math.sin(delTheta_c), 0, 4.0*math.cos(delTheta_c)]]).T
            vel_l = np.vstack((w_l, v_l))
            checkPose_l = curPose.compose(gtsam.Pose3.Expmap(vel_l))
            bnd_l = checkPose_l.translation()

            delTheta_c = (math.pi / 180.0 * 30)
            w_r = np.array([[0, delTheta_c, 0]]).T
            v_r = np.array([[4.0 * math.sin(delTheta_c), 0, 4.0 * math.cos(delTheta_c)]]).T
            vel_r = np.vstack((w_r, v_r))
            checkPose_r = curPose.compose(gtsam.Pose3.Expmap(vel_r))
            bnd_r = checkPose_r.translation()
            if abs(bnd_l[0]) >= 10 or abs(bnd_l[1]) >= 10:
                vel = np.vstack((w_r, v_r*0.2/4.0))
            elif abs(bnd_r[0] >= 10) or abs(bnd_r[1] >= 10) :
                vel = np.vstack((w_l, v_l*0.2/4.0))
            else:
                ################
                delTheta = -1.0 * (math.pi / 180.0 * 20) + np.random.rand() * (math.pi / 180.0 * 40)
                w = np.array([[0, delTheta, 0]]).T
                v = np.array([[0.3*math.sin(delTheta), 0, 0.3*math.cos(delTheta)]]).T
                #v = np.array([[-0.2 + np.random.rand(), 0, -0.2 + np.random.rand()]]).T
                vel = np.vstack((w, v))
        else:
            vel = vel_cmds[i]
        curPose = curPose.compose(gtsam.Pose3.Expmap(vel))
    return poses

def create_forward_side_robot_traj(start_rot=np.eye(3), start_trans=np.array([0,0,0]), num_poses=30, forward=True):
    # plt.ion()
    # fig1, ax1 = visualize.initialize_3d_plot(number=1, limits=np.array([[-30, 30], [-30, 30], [-30, 30]]),
    #                                                 view=[-30, -90])
    # plot GTSAM poses
    curPose = gtsam.Pose3(gtsam.Rot3(start_rot), gtsam.Point3(start_trans))
    poses = []
    for i in range(num_poses):
        poses.append(curPose)
        # plot.plot_pose3_on_axes(ax1, curPose, axis_length=1, P=None, scale=1)

        w = np.array([[0, 0, 0]]).T
        if forward:
            v = np.array([[0.0, 0, 0.5]]).T
        else:
            v = np.array([[0.5, 0, 0.0]]).T
        #v = np.array([[-0.2 + np.random.rand(), 0, -0.2 + np.random.rand()]]).T
        vel = np.vstack((w, v))

        curPose = curPose.compose(gtsam.Pose3.Expmap(vel))
        # ax1.set_xlim3d([-10, 10])
        # ax1.set_ylim3d([-10, 10])
        # ax1.set_zlim3d([-10, 10])
        # fig1.canvas.draw()
        # fig1.canvas.flush_events()
        # time.sleep(0.2)
        # ax1.cla()
    return poses

def create_room_world(num_points,num_poses, K, add_ground= False, to_plot=False):
    if to_plot:
        plt.ion()
        fig1, ax1 = visualize.initialize_3d_plot(number=1, limits=np.array([[-30, 30], [-30, 30], [-30, 30]]),
                                                        view=[-90, -90])

    # helper_functions.plot_3d_points(ax1, pp, None, 'bo', markersize=2)
    wall_width = 20
    wall_height = 9
    # generate random points on xy plane
    num_points = int(num_points/4)
    if add_ground:
        x_g = -1.0* (wall_width/2.0) + np.random.rand(num_points*2) * wall_width
        y_g = -1.0*(wall_height) + np.random.rand(num_points*2) * (wall_height*2.0)
        z_g = np.zeros((1, num_points*2))

    # rotate the points
    R_y = np.array([[math.cos(math.pi / 2), 0, math.sin(math.pi / 2)],
                    [0, 1, 0],
                    [-1 * math.sin(math.pi / 2), 0, math.cos(math.pi / 2)]])

    R_z = np.array([[math.cos(math.pi / 2), -1 * math.sin(math.pi / 2), 0.0],
                    [math.sin(math.pi / 2), math.cos(math.pi / 2), 0.0],
                    [0, 0, 1.0]])

    R_z_neg = np.array([[math.cos(math.pi / 2), math.sin(math.pi / 2), 0.0],
                        [-1 * math.sin(math.pi / 2), math.cos(math.pi / 2), 0.0],
                        [0, 0, 1.0]])

    R_x = np.array([[1.0, 0.0, 0.0],
                    [0, math.cos(math.pi / 2), -1 * math.sin(math.pi / 2)],
                    [0, math.sin(math.pi / 2), math.cos(math.pi / 2)]])

    x = -1.0 * (wall_width / 2.0) + np.random.rand(num_points) * wall_width
    y = -1.0 * (wall_height / 2.0) + np.random.rand(num_points) * (wall_height)
    z = np.zeros((1, num_points))
    points = np.vstack((x, y, z))

    rotated_points_1 = (R_x @ R_y @ points).T + np.array([-wall_width/2.0, 0, wall_height / 2.0])
    # helper_functions.plot_3d_points(ax1, points.T, None, 'bo', markersize=2)


    x = -1.0 * (wall_width / 2.0) + np.random.rand(num_points) * wall_width
    y = -1.0 * (wall_height / 2.0) + np.random.rand(num_points) * (wall_height)
    z = np.zeros((1, num_points))
    points = np.vstack((x, y, z))
    rotated_points_2 = (R_x @ points).T + np.array([0.0, wall_width/2.0, wall_height / 2.0])


    x = -1.0 * (wall_width / 2.0) + np.random.rand(num_points) * wall_width
    y = -1.0 * (wall_height / 2.0) + np.random.rand(num_points) * (wall_height)
    z = np.zeros((1, num_points))
    points = np.vstack((x, y, z))
    rotated_points_3 = (R_z_neg @ R_x @ points).T + np.array([wall_width/2.0, 0.0, wall_height / 2.0])


    x = -1.0 * (wall_width / 2.0) + np.random.rand(num_points) * wall_width
    y = -1.0 * (wall_height / 2.0) + np.random.rand(num_points) * (wall_height)
    z = np.zeros((1, num_points))
    points = np.vstack((x, y, z))
    rotated_points_4 = (R_x @ points).T + np.array([0.0, -wall_width/2.0, wall_height / 2.0])
    if to_plot:
        visualize.plot_3d_points(ax1, rotated_points_1, None, 'ro', markersize=2)
        visualize.plot_3d_points(ax1, rotated_points_2, None, 'ro', markersize=2)
        visualize.plot_3d_points(ax1, rotated_points_3, None, 'ro', markersize=2)
        visualize.plot_3d_points(ax1, rotated_points_4, None, 'ro', markersize=2)

    num_g_points=0
    if add_ground:
        points_ground = np.vstack((x_g, y_g, z_g)).T
        if to_plot:
            visualize.plot_3d_points(ax1, points_ground, None, 'ro', markersize=2)
        points = np.vstack((rotated_points_1, rotated_points_2, rotated_points_3, rotated_points_4, points_ground))
        num_g_points = num_points*2
    else:
        points = np.vstack((rotated_points_1, rotated_points_2, rotated_points_3, rotated_points_4))
    #print(rotated_points_1)
    #print(points.shape)
    tot_num_points = num_points*4 + num_g_points
    points_gtsam = [Point3(points[i, 0], points[i, 1], points[i, 2]) for i in range(tot_num_points)]
    #print(points_gtsam)

    # plot GTSAM poses
    radius = 5.0
    height = wall_height/2.0
    angles = np.linspace(0, 2 * np.pi, num_poses, endpoint=False)
    up = gtsam.Point3(0, 0, 1)
    target = gtsam.Point3(0, 0, height)
    poses = []

    for theta in angles:
        position = gtsam.Point3(radius * np.cos(theta), radius * np.sin(theta), height)
        #target = gtsam.Point3(3 * radius * np.cos(theta), 3 * radius * np.sin(theta), height)
        camera = gtsam.PinholeCameraCal3_S2.Lookat(position, target, up, K)
        poses.append(camera.pose())
        # plot.plot_pose3_on_axes(ax1, camera.pose(), axis_length=1, P=None, scale=1)

    #cid = fig1.canvas.mpl_connect('key_press_event', plot)
    # sanity check
    if to_plot:
        for i, pose in enumerate(poses):
            plot.plot_pose3_on_axes(ax1, pose, axis_length=1, P=None, scale=1)
            camera = PinholeCameraCal3_S2(pose, K)
            num_projected = 0
            for j, point in enumerate(points_gtsam):
                try:
                    measurement = camera.project(point) + 1.0 * np.random.randn(2)
                    if (measurement[0] > 1 and measurement[0] < 2 * K.px() and measurement[1] > 1 and measurement[
                        1] < 2 * K.py()):
                        num_projected = num_projected + 1
                        plot.plot_point3_on_axes(ax1,point,'b*')
                    # else:
                    # print("Measurement is out of bounds: ")
                    # print(measurement)
                except Exception:
                    pass
                    # print("Exception at Point")
                    # print(point)
            fig1.canvas.draw()
            fig1.canvas.flush_events()
            time.sleep(0.5)
            ax1.cla()
            # visualize.plot_3d_points(ax1, rotated_points_1, None, 'ro', markersize=2)
            # visualize.plot_3d_points(ax1, rotated_points_2, None, 'ro', markersize=2)
            # visualize.plot_3d_points(ax1, rotated_points_3, None, 'ro', markersize=2)
            # visualize.plot_3d_points(ax1, rotated_points_4, None, 'ro', markersize=2)
            visualize.plot_3d_points(ax1, points, None, 'ro', markersize=2)
            #print(pose)
            #print("number of projected measurements for pose : " + str(i) + " is : " + str(num_projected))
        plt.ioff()
    return points_gtsam, poses


def generate_measurements(points, poses, extrinsics,intrinsics, toplot=False):
    """
    This method takes in the camera configuration candidates, groundtruth poses and landmarks
    and generates noisy measuerments in the cameras.
    """
    dict = {}
    measurements = np.zeros((len(poses), len(extrinsics),len(points), 2))
    measurement_errs = []
    # Simulated measurements from each camera pose, adding them to the factor graph
    for i, pose in enumerate(poses):
        for k, comp_pose in enumerate(extrinsics):
            # compose pose with comp_pose T_wb * T_bc = T_wc, we get the pose of component camera W.R.T world
            pose_wc = pose.compose(comp_pose)
            camera = PinholeCameraCal3_S2(pose_wc, intrinsics[k])
            # print(pose)
            # print(comp_pose)
            # print(pose_wc)
            for j, point in enumerate(points):
                try:
                    projection_gt = camera.project(point)
                    if (projection_gt[0] > 1 and projection_gt[0] < (2 * intrinsics[k].px() - 2) and projection_gt[1] > 1 and projection_gt[
                        1] < (2 * intrinsics[k].py() - 2)):
                        measurement = projection_gt + 1.0 * np.random.randn(2)
                        measurements[i,k,j] = measurement
                        m_err = projection_gt - measurement
                        measurement_errs.append(m_err)
                        #print("measurement at [{},{},{}]: ({:.6f}, {:.6f}, error:[{:.6f}, {:.6f}] )".format(i, k, j,measurement[0],
                        #                                                                    measurement[1], m_err[0],  m_err[1]))
                        if dict.get(j) is None:
                            dict[j] = 1
                        else:
                            dict[j] = dict[j] + 1
                    else:
                        # print("Measurement is out of bounds: ")
                        # print(measurement)
                        pass

                except Exception:
                    pass
                    # print("Exception at Point")
                    # print(point)
    '''
       plot the measurement error distribution
       for sanity check
       '''
    if toplot:
        visualize.initialize_2d_plot()
        visualize.plot_2d_points(np.array(measurement_errs))
    # This is not needed for localizaruion
    rm_indices = []
    # for k, v in dict.items():
    #     if v < 2:
    #         #print("lm index: " + str(k) + ", lm value : " + str(points[k]))
    #         rm_indices.append(k)
    points_mask = np.ones(len(points))
    for i, pt in enumerate(points):
        if (i in rm_indices) or (i not in dict.keys()):
            points_mask[i] = 0

    return measurements

def generate_simulation_data(K, traj_type, num_points, num_poses, to_plot=False ):
    ''' calibration intrinsic params'''
    ''' Generate all possible candidates rotations and translations'''
    #(0, 3 / 2 * math.pi), 7
    pose_rots, pose_trans = generate_candidate_poses((0, 330/180*math.pi), 12, (0, math.pi / 2),
                                                               1)  # (0, math.pi / 2), 1) #(-math.pi / 2, math.pi / 2), 4) #
    #(0, 3 / 2 * math.pi), 7, (-math.pi / 2, math.pi / 2),5
    # pose_rots, pose_trans = utilities.generate_candidate_poses((0, 1), 1, (0, 1),1)  # (0, math.pi / 2), 1) #(-math.pi / 2, math.pi / 2), 4) #
    ''' generate a room world with landmarks on the 4 walls of the room and a circular trajectory '''
    points, poses = create_room_world(num_points, num_poses, K, add_ground=False, to_plot=False)
    # sideward
    height = 4.5
    up = Point3(0, 0, 1)
    position = Point3(0, 0, height)
    target = Point3(0.0, 3.0, height)
    camera = PinholeCameraCal3_S2.Lookat(position, target, up, K)
    rott = camera.pose().rotation().matrix()
    if traj_type == 2:
        poses = create_forward_side_robot_traj(rott, np.array([-5.0, 0.0, 5.0]), num_poses, False)
    elif traj_type == 3:
        poses = create_forward_side_robot_traj(rott, np.array([0.0, -10.0, 5.0]), num_poses)
    elif traj_type == 4:
        poses = create_random_robot_traj(rott, np.array([0.0, -10.0, 5.0]), num_poses)
    if to_plot:
        visualize.show_trajectories(poses, points, K, 2, "side_traj")
    # extr_cand = []
    # for j, trans in enumerate(pose_trans):
    #     for k, rot in enumerate(pose_rots):
    #         cam = gtsam.Pose3(gtsam.Rot3(rot), gtsam.Point3(trans[0], trans[1], trans[2]))
    #         extr_cand.append(cam)
    extr_cand = generate_extr_cands_phy(pose_trans, pose_rots)
    intrinsics = [K] * len(extr_cand)
    intrinsics = [K] * len(extr_cand)
    ''' #Generate noisy measurements for all the candidate cameras'''
    measurements = generate_measurements(points, poses, extr_cand,intrinsics, to_plot)
    ''' create initial values for poses and landmarks and use them for graphs formed by different methods'''
    poses_with_noise = []
    points_with_noise = []
    for p in poses:
        transformed_pose = p.retract(0.1 * np.random.randn(6, 1))
        poses_with_noise.append(transformed_pose)
    for l in points:
        transformed_point = l + 0.1 * np.random.randn(3)
        points_with_noise.append(transformed_point)
    return poses, points, measurements, extr_cand, intrinsics, poses_with_noise, points_with_noise


def generate_meas_extr_EQUAL(poses, points, K, select_list):
    extr_cand_e = generate_candidate_poses_equal(select_list)
    intrinsics = [K] * len(extr_cand_e)
    ''' #Generate noisy measurements for all the candidate cameras'''
    measurements_e = generate_measurements(points, poses, extr_cand_e, intrinsics)

    return measurements_e, extr_cand_e, intrinsics

def generate_meas_extr_STANDARD(poses, points, K, select_list):
    extr_cand_s = generate_candidate_poses_stnd(select_list)
    intrinsics = [K] * len(extr_cand_s)
    ''' #Generate noisy measurements for all the candidate cameras'''
    measurements_s = generate_measurements(points, poses, extr_cand_s, intrinsics)

    return measurements_s, extr_cand_s, intrinsics
